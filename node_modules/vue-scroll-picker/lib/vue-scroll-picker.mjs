import { defineComponent as p, h as a, renderSlot as h } from "vue";
function v(t, e = 83) {
  let i = null;
  return function() {
    i && (clearTimeout(i), i = null);
    const s = this, n = arguments;
    i = setTimeout(() => t.apply(s, n), e);
  };
}
function x(t) {
  const { top: e, bottom: i } = t.getBoundingClientRect();
  return (e + i) / 2;
}
function d(t) {
  return t.map((e) => {
    switch (typeof e) {
      case "string":
        return { value: e, name: e };
      case "number":
      case "boolean":
        return { value: e, name: `${e}` };
    }
    return e;
  });
}
function u(t) {
  return t.changedTouches || t.touches;
}
function c(t) {
  return u(t) ? t.changedTouches[0] || t.touches[0] : t;
}
const I = p({
  props: {
    modelValue: null,
    options: {
      type: Array,
      default: () => []
    },
    dragSensitivity: {
      type: Number,
      default: 1.7
    },
    touchSensitivity: {
      type: Number,
      default: 1.7
    },
    scrollSensitivity: {
      type: Number,
      default: 1
    },
    empty: {
      type: String,
      default: "No Items"
    },
    placeholder: {
      type: String,
      default: null
    }
  },
  data() {
    var s, n;
    const t = d(this.options);
    let e = t.findIndex((l) => l.value == this.modelValue);
    e === -1 && !this.placeholder && !this.$slots.placeholder && this.options.length > 0 && (e = 0);
    const i = (n = (s = t[e]) == null ? void 0 : s.value) != null ? n : null;
    return {
      refItems: [],
      internalOptions: t,
      internalIndex: e,
      internalValue: i,
      pivots: [],
      pivotsMin: 0,
      pivotsMax: 0,
      scroll: null,
      scrollOffsetTop: 0,
      scrollMin: 0,
      scrollMax: 0,
      transitioning: !1,
      transitionTimer: null,
      start: null,
      isMouseDown: !1,
      isDragging: !1
    };
  },
  computed: {
    hasPlaceholder() {
      return !!(this.placeholder || this.$slots.placeholder);
    }
  },
  watch: {
    modelValue(t) {
      if (t == null && this.hasPlaceholder) {
        this.correction(-1);
        return;
      }
      const e = this.internalOptions.findIndex((i) => i.value == t);
      if (e === -1) {
        this.$emit("update:modelValue", this.internalValue);
        return;
      }
      this.internalIndex !== e && this.correction(e);
    },
    options: {
      handler(t) {
        var n, l;
        const e = this.internalOptions = d(t);
        let i = e.findIndex((o) => o.value == this.modelValue);
        i === -1 && !this.hasPlaceholder && this.options.length > 0 && (i = 0);
        const s = (l = (n = e[i]) == null ? void 0 : n.value) != null ? l : null;
        this.$nextTick(() => {
          this.calculatePivots(), this.scroll = this.findScrollByIndex(i), this.internalIndex = i, this.internalValue !== s && this.$emit("update:modelValue", this.internalValue = s);
        });
      },
      deep: !0
    }
  },
  beforeUpdate() {
    this.refItems = [];
  },
  mounted() {
    this.calculatePivots(), this.scroll = this.findScrollByIndex(this.internalIndex), this.internalValue !== this.modelValue && this.$emit("update:modelValue", this.internalValue);
    const t = this.$el;
    t.addEventListener("touchstart", this.onStart), t.addEventListener("touchmove", this.onMove), t.addEventListener("touchend", this.onEnd), t.addEventListener("touchcancel", this.onCancel), "onwheel" in t ? t.addEventListener("wheel", this.onWheel) : "onmousewheel" in t ? t.addEventListener("mousewheel", this.onWheel) : "onDOMMouseScroll" in t && t.addEventListener("DOMMouseScroll", this.onWheel), t.addEventListener("mousedown", this.onStart), document.addEventListener("mousemove", this.onMove), document.addEventListener("mouseup", this.onEnd), document.addEventListener("mouseout", this.onDocumentMouseOut);
  },
  beforeUnmount() {
    const t = this.$el;
    t.removeEventListener("touchstart", this.onStart), t.removeEventListener("touchmove", this.onMove), t.removeEventListener("touchend", this.onEnd), t.removeEventListener("touchcancel", this.onCancel), "onwheel" in t ? t.removeEventListener("wheel", this.onWheel) : "onmousewheel" in t ? t.removeEventListener("mousewheel", this.onWheel) : "onDOMMouseScroll" in t && t.removeEventListener("DOMMouseScroll", this.onWheel), t.removeEventListener("mousedown", this.onStart), document.removeEventListener("mousemove", this.onMove), document.removeEventListener("mouseup", this.onEnd), document.removeEventListener("mouseout", this.onDocumentMouseOut);
  },
  methods: {
    setRefItem(t) {
      this.refItems.push(t);
    },
    resize() {
      this.$nextTick(() => {
        this.calculatePivots(), this.scroll = this.findScrollByIndex(this.internalIndex);
      });
    },
    calculatePivots() {
      const t = this.$refs.rotator, e = this.$refs.layerSelection, i = t.getBoundingClientRect().top, s = this.pivots = this.refItems.map((r) => x(r) - i).sort((r, m) => r - m), n = this.pivotsMin = Math.min(...s), l = this.pivotsMax = Math.max(...s), o = this.scrollOffsetTop = e.offsetTop + e.offsetHeight / 2;
      this.scrollMin = o - n, this.scrollMax = o - l;
    },
    sanitizeInternalIndex(t) {
      return Math.min(Math.max(t, this.hasPlaceholder ? -1 : 0), this.internalOptions.length - 1);
    },
    findIndexFromScroll(t) {
      let e = null, i = 0;
      return this.pivots.forEach((s, n) => {
        const l = s + t - this.scrollOffsetTop;
        (e === null || Math.abs(e) > Math.abs(l)) && (i = n, e = l);
      }), this.hasPlaceholder || this.options.length === 0 ? i - 1 : i;
    },
    findScrollByIndex(t) {
      let e = t;
      return (this.hasPlaceholder || this.options.length === 0) && e++, t > -1 && e in this.pivots ? this.scrollOffsetTop - this.pivots[e] : t >= this.pivots.length ? this.scrollOffsetTop - this.pivotsMax : this.scrollOffsetTop - this.pivotsMin;
    },
    onWheel(t) {
      var o, r;
      if (this.scroll >= this.scrollMin && t.deltaY < 0 || this.scroll <= this.scrollMax && t.deltaY > 0 || this.pivots.length === 1)
        return;
      t.preventDefault();
      const e = this.sanitizeInternalIndex(this.internalIndex + (t.deltaY > 0 ? 1 : -1)), i = t.deltaY > 0 ? this.findScrollByIndex(e - 1) - this.findScrollByIndex(e) : this.findScrollByIndex(e) - this.findScrollByIndex(e + 1), s = Math.max(Math.min(t.deltaY, i), i * -1);
      this.scroll = Math.min(Math.max(this.scroll - s * this.scrollSensitivity, this.scrollMax), this.scrollMin);
      const n = this.sanitizeInternalIndex(this.findIndexFromScroll(this.scroll)), l = (r = (o = this.internalOptions[n]) == null ? void 0 : o.value) != null ? r : null;
      this.internalIndex = n, this.internalValue !== l && this.$emit("update:modelValue", this.internalValue = l), this.onAfterWheel(() => {
        this.correction(this.findIndexFromScroll(this.scroll));
      });
    },
    onAfterWheel: v((t) => {
      t();
    }, 200),
    onStart(t) {
      t.cancelable && t.preventDefault();
      const { clientY: e } = c(t);
      this.start = [this.scroll, e], u(t) || (this.isMouseDown = !0), this.isDragging = !1;
    },
    onMove(t) {
      if (t.cancelable && t.preventDefault(), !this.start)
        return;
      const { clientY: e } = c(t), i = e - this.start[1];
      Math.abs(i) > 1.5 && (this.isDragging = !0), this.scroll = this.start[0] + i * (u(t) ? this.touchSensitivity : this.dragSensitivity);
    },
    onEnd(t) {
      t.cancelable && t.preventDefault(), this.isDragging ? this.correction(this.findIndexFromScroll(this.scroll)) : this.isMouseDown && this.onClick(t), this.start = null, this.isDragging = !1, this.isMouseDown = !1;
    },
    onDocumentMouseOut(t) {
      var e;
      (t.relatedTarget === null || ((e = t.relatedTarget) == null ? void 0 : e.nodeName) === "HTML") && this.onCancel(t);
    },
    onCancel(t) {
      t.cancelable && t.preventDefault(), this.correction(this.internalIndex), this.start = null, this.isMouseDown = !1, this.isDragging = !1;
    },
    onClick(t) {
      const e = this.$refs.layerTop, i = this.$refs.layerBottom, s = c(t), n = s.clientX, l = s.clientY, o = e.getBoundingClientRect(), r = i.getBoundingClientRect();
      o.left <= n && n <= o.right && o.top <= l && l <= o.bottom ? this.correction(this.internalIndex - 1) : r.left <= n && n <= r.right && r.top <= l && l <= r.bottom && this.correction(this.internalIndex + 1);
    },
    correction(t) {
      var s, n;
      const e = this.sanitizeInternalIndex(t), i = (n = (s = this.internalOptions[e]) == null ? void 0 : s.value) != null ? n : null;
      this.scroll = this.findScrollByIndex(e), this.transitioning = !0, this.transitionTimer && (clearTimeout(this.transitionTimer), this.transitionTimer = null), this.transitionTimer = setTimeout(() => {
        this.transitioning = !1, this.transitionTimer = null, this.internalIndex = e, this.internalValue !== i && this.$emit("update:modelValue", this.internalValue = i);
      }, 100);
    }
  },
  render() {
    let t = [];
    return this.hasPlaceholder ? t.push(a("div", {
      class: [
        "vue-scroll-picker-item",
        "vue-scroll-picker-item-placeholder",
        {
          "vue-scroll-picker-item-selected": this.internalIndex === -1
        }
      ],
      ref: (e) => e && this.setRefItem(e)
    }, h(this.$slots, "placeholder", { text: this.placeholder }, () => [
      this.placeholder
    ]))) : this.internalOptions.length === 0 && t.push(a("div", {
      class: [
        "vue-scroll-picker-item",
        "vue-scroll-picker-item-empty",
        "vue-scroll-picker-item-selected"
      ],
      ref: (e) => e && this.setRefItem(e)
    }, h(this.$slots, "empty", { text: this.empty }, () => [
      this.empty
    ]))), t = t.concat(this.internalOptions.map((e, i) => a("div", {
      class: [
        "vue-scroll-picker-item",
        {
          "vue-scroll-picker-item-selected": this.internalIndex === i
        }
      ],
      key: e.value,
      ref: (s) => s && this.setRefItem(s)
    }, h(this.$slots, "default", { option: e }, () => [
      e.name
    ])))), a("div", {
      class: [
        "vue-scroll-picker"
      ]
    }, [
      a("div", {
        ref: "rotator",
        class: [
          "vue-scroll-picker-rotator",
          {
            "vue-scroll-picker-rotator-transition": this.transitioning
          }
        ],
        style: typeof this.scroll == "number" ? { top: `${this.scroll}px` } : {}
      }, t),
      a("div", { class: ["vue-scroll-picker-layer"] }, [
        a("div", { class: ["vue-scroll-picker-layer-top"], ref: "layerTop" }),
        a("div", { class: ["vue-scroll-picker-layer-selection"], ref: "layerSelection" }),
        a("div", { class: ["vue-scroll-picker-layer-bottom"], ref: "layerBottom" })
      ])
    ]);
  }
});
function f(t) {
  t.component("VueScrollPicker", I);
}
typeof window < "u" && window.Vue && f(window.Vue);
const M = {
  install: f
};
export {
  I as VueScrollPicker,
  M as default,
  f as install
};
//# sourceMappingURL=vue-scroll-picker.mjs.map
